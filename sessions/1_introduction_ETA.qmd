---
title: "Introduction to Ecological Trajectory Analysis"
title-slide-attributes: 
  data-background-color: "#008080"
format:
  revealjs:
    embed-resources: true
    incremental: true
    smaller: true
    logo: resources/img/logos.png
    theme: [default, resources/scss/custom.scss]
editor: source
author: "Miquel De Cáceres, Anthony Sturbois, Nicolas Djeghri, Javi de la Casa"
institute: "EMF-CREAF, CSIC, LEMAR"
toc: false
toc-depth: 2
number-sections: false
slide-number: true
progress: true
---

# Outline {background-color="#008080"}

::::: columns
::: {.column width="50%"}
1. Introduction
2. Conceptual and geometric elements
3. Trajectory objects
4. Characterizing trajectories
5. Comparing target states to reference trajectories
6. Comparing pairs of trajectories
7. Variation in ecological dynamics
8. Transforming trajectories
:::

::: {.column width="50%"}

![M.C. Escher - Waterfall, 1961](resources/img/Escher_waterfall.png)
:::
:::::


# 1. Introduction {background-color="#008080"}

## Analytical frameworks related to ecological trajectories

**Initial state reference**

![](resources/img/Bagchi.webp)

*Bagchi S.,et al. 2017. Quantifying long-term plant community dynamics with movement models: Implications for ecological resilience. Ecological Applications 27: 1514–1528.*

::: footer
1.  Introduction
:::

## Analytical frameworks related to ecological trajectories

**Second-stage community analysis**

![](resources/img/Clarke.png)

*Clarke et al. 2006. Exploring interactions by second-stage community analyses. Journal of Experimental Marine Biology and Ecology 338: 179–192.*

::: footer
1.  Introduction
:::

## About Ecological Trajectory Analysis

**What is Ecological Trajectory Analysis?**

Ecological Trajectory Analysis (ETA) is a framework to analyze the dynamics of ecological entities (e.g. communities or ecosystems).

. . .

**Brief history of ETA**

 + In 2019, De Cáceres et al, presented **Community Trajectory Analysis (CTA)** as a framework for trajectory analysis in community ecology.

 + The initial framework was extended with new metrics and visualisation modes in Sturbois et al. (2021a).

 + The same framework was applied to stable isotope data in Sturbois et al. (2021b), referring to it as **Stable Isotope Trajectory Analysis (SITA)**.
 
 + Instrumental to develop another methodological framework to identify, characterize and compare **Ecological Dynamic Regimes (EDR)** (Sánchez-Pinillos et al. 2023).
 
 + Recently applied in a **paleoecological context** using elemental composition data (de la Casa et al. 2025).

 + More recently, the framework has been extended to cyclical data (Djeghri et al. 2026), under the name of **Cyclical Ecological Trajectory Analysis (CETA)**.
 
. . .



::: footer
1.  Introduction
:::

## Package **ecotraj**

![](resources/img/logo_ecotraj.png){.absolute width="80" right="200" top="30"}

The ETA framework is implemented in package **ecotraj**:

. . .

**Installation**

Package **ecotraj** (ver. 1.1.0) is distributed from [CRAN](https://cran.r-project.org/web/packages/ecotraj/index.html) and can be installed using:

```{r, eval = FALSE, include = TRUE, echo = TRUE}
install.packages("ecotraj")
```

More frequent updates can be obtained if installing from **GitHub** (compilation tools are required):

```{r, eval = FALSE, include = TRUE, echo = TRUE}
remotes::install_github("emf-creaf/ecotraj")
```

. . .

**Documentation**

Although the package comes with function documentation, the complete function reference and articles explaining how to use the package can be found at [https://emf-creaf.github.io/ecotraj/](https://emf-creaf.github.io/ecotraj/).

. . .

**Loading**

We begin by loading **ecotraj**  (ver. `r packageVersion("ecotraj")`)  to the workspace:

```{r, echo = TRUE, eval = TRUE}
library(ecotraj)
```

::: footer
1.  Introduction
:::



# 2. Conceptual and geometric elements {background-color="#008080"}

## Conceptual elements

The most important *conceptual* elements of ETA are:


| Element   | Notation | Description                                                  |
|-------------------|--|---------------------------------------------------|
| *Target entity*  |  | The ecological entity whose dynamics are of interest. It can be an individual, a population, a community or an entire ecosystem                                    |
| *Ecological observation* | $\mathbf{o}$  | The assessment of the state of a target entity, normally implying multiple attributes, at a given point in time.  We also use the word observation to refer to the pair including the ecological state and time of assessment.                        |
| *Survey* | | An indication of the order of ecological observations (e.g. first, second, …), sometimes taken as a surrogate of linear time. |
| *Ecological state* | $\mathbf{x}$ | The feature values of a target entity when assessed at given point in time. In practice, it corresponds to an (implicit or explicit) position in $\Omega_0$. |
| *Multivariate state space* | $\Omega_0$ | The multidimensional space of ecological states. While $\Omega_0$ could be defined by explicit orthogonal axes, in ETA it is defined by calculating the dissimilarity ($d$) between all pairs of states. Therefore it can use **all dimensions** of ecological resemblance. |
| *Time* | $t$ | The position of a given ecological observation in a (linear) temporal axis (i.e. ‘when’ the assessment act occurred).  |

. . .

::: callout-note
Recurrent or cyclical time is another conceptual element in [Cyclical Ecological Trajectory Analysis (CETA)](https://emf-creaf.github.io/ecotraj/articles/IntroductionCETA.html).
:::

::: footer
2.  Conceptual and geometric elements
:::

## Geometric elements (1)

The most important *geometric* elements of ETA are:

:::: {.columns}

::: {.column width="75%"}
| Element   | Notation | Description                                                  |
|-------------------|--|---------------------------------------------------|
| *Ecological state* | $\mathbf{x}$ | The position of an observation in space $\Omega_0$. |
| *Directed segment* | $\mathbf{s}$ | A pair of time-ordered ecological states. |
| *Ecological observation* | $\mathbf{o}$ | A pair including the ecological state $\mathbf{x}$ and the assessment time $t$, i.e. $\mathbf{o} = \{ \mathbf{x}, t \}$. |
| *Ecological trajectory* | $\mathbf{T}$ | A trajectory of size $n$ is defined as the set of $n$ time-ordered ecological observations. Alternatively, $\mathbf{T}$ can be defined as a set of $n - 1$ directed segments. |
:::

::: {.column width="25%"}
![](resources/img/trajectory.webp)
:::

::::


::: footer
2.  Conceptual and geometric elements
:::


## Geometric elements (2)

The most important *geometric* elements of ETA are:

:::: {.columns}

::: {.column width="60%"}
| Element   | Description                                                  |
|-------------------|---------------------------------------------------|
| *Ecological sub-trajectory* | A trajectory derived from a time-ordered subset of the observations of its parent trajectory. |
| *Trajectory path* | A continuous function $f_T: [0,1]$ into $\Omega_0$, defining all points of the trajectory $\mathbf{T}$ from $f_T(0) = x_1$ to $f_T(1) = x_n$. The path includes the ecological states derived from ecological observations as well as intermediate states. |
| *Trajectory section* | A trajectory describing a subset of its parent trajectory path.  |

:::

::: {.column width="40%"}
![](resources/img/trajectory_subsets.webp)
:::

::::
. . .

::: callout-note
Other geometry elements are defined in [Cyclical Ecological Trajectory Analysis (CETA)](https://emf-creaf.github.io/ecotraj/articles/IntroductionCETA.html).
:::

::: footer
2.  Conceptual and geometric elements
:::

# 3. Trajectory objects {background-color="#008080"}

## Trajectory data inputs

Trajectory data inputs for ETA are: 

  a. Trajectory metadata describing **entities** and **observations**. 
  b. A distance matrix $\mathbf{D}$ representing the resemblance between all pairs of ecological states.

. . .

**Metadata**

In this session we will primarily use a small data set where three entities have been observed four times:

```{r, echo = TRUE}
entities <- c("1","1","1","1","2","2","2","2","3","3","3","3")
times <- c(1.0,2.0,3.0,4.0,1.0,1.75,2.5,3.25,1.0,1.5,2.0,2.5)
```

. . .

**Distance matrix**

We will assume that ecological states can be compared using the *Euclidean distance* and only two variables have been measured:

```{r, echo = TRUE}
xy<-matrix(0, nrow=12, ncol=2)
xy[2,2]<-1
xy[3,2]<-2
xy[4,2]<-3
xy[5:6,2] <- xy[1:2,2]
xy[7,2]<-1.5
xy[8,2]<-2.0
xy[5:6,1] <- 0.25
xy[7,1]<-0.5
xy[8,1]<-1.0
xy[9:10,1] <- xy[5:6,1]+0.25
xy[11,1] <- 1.0
xy[12,1] <-1.5
xy[9:10,2] <- xy[5:6,2]
xy[11:12,2]<-c(1.25,1.0)
```

. . .

The distance matrix is obtained using:

```{r, echo = TRUE}
d <- dist(xy)
```


::: footer
3.  Trajectory objects
:::

## Creating trajectory objects

Dynamic information is contained in objects of class `trajectories`.

. . .

To build them, we need to combine the distance matrix ($\mathbf{D}$) and the entity/survey information in a single object using function `defineTrajectories()`:


```{r, echo = TRUE}
x <- defineTrajectories(d, entities)
```

. . .

The function returns an object (a list) of class `trajectories` that contains all the information for analysis:

```{r, echo = TRUE}
class(x)
```

. . .

This object contains two elements:
```{r, echo = TRUE}
names(x)
```

. . .

Element `d` contains the input distance matrix ($\mathbf{D}$), whereas `metadata` is a data frame including information of observations:

```{r, echo = TRUE}
x$metadata
```

::: footer
3.  Trajectory objects
:::


## Creating trajectory objects

Note that `x` does not contain observation times (they are assumed to be equal to surveys).

. . .

In our examples we will also use another object where we include observation times: 

```{r, echo = TRUE}
xt <- defineTrajectories(d, entities, times = times)
xt$metadata
```

One particularity of this second trajectory object `xt` is that trajectories are not synchronous (observation times are not the same across trajectories):

```{r, echo = TRUE}
is.synchronous(x)
is.synchronous(xt)
```


::: footer
3.  Trajectory objects
:::

## Subsetting trajectory objects

At some point in the ETA, one may desire to focus on particular trajectories or surveys. Function `subsetTrajectory()` allows subsetting objects of class `trajectories`, For example, we can decide to work with the trajectories of the second and third entities (sites):

```{r, echo = TRUE}
x23 <- subsetTrajectories(xt, site_selection = c("2", "3"))
x23
```

::: footer
3.  Trajectory objects
:::

## Drawing trajectories

To begin our analysis of the three trajectories, we display them in an ordination space, using function `trajectoryPCoA()`:

```{r pcoa, echo = TRUE, fig = TRUE, fig.height=5, fig.width=5, fig.align = "center"}
trajectoryPCoA(xt, 
               traj.colors = c("black","red", "blue"), lwd = 2,
               time.labels = TRUE)
legend("topright", col=c("black","red", "blue"), 
       legend=c("Entity 1", "Entity 2", "Entity 3"), bty="n", lty=1, lwd = 2)
```

. . .

Since $\Omega_0$ has only two dimensions in this example, the Principal Coordinates Analysis (PCoA) on matrix $\mathbf{D}$ displays the complete space.

::: footer
3.  Trajectory objects
:::

# 4. Characterizing trajectories {background-color="#008080"}

## Characterizing changes in state

:::: {.columns}

::: {.column width="70%"}

| Metric            |  Description                                       |
|-------------------|----------------------------------------------------|
| *Segment length*  | The length of a segment $\mathbf{s}$ is given by the distance between its two endpoints. |
| *Total path length*  | The total path length of a trajectory $\mathbf{T}$ is the sum of the lengths of its directed segments. |
| *Segment speed*  | When associated to explicit time coordinates $t_{start}$ and $t_{end}$, the speed of change of a segment $\mathbf{s}$ is defined as the length divided by its duration. |
| *Trajectory speed*  | The average speed of change in trajectory $\mathbf{T}$ is estimated as the total path length divided by its duration. |
| *Net change* | For any state $\mathbf{x}_i$ of a trajectory $\mathbf{T}$, the net change is defined as the distance with respect to the initial (reference) state $\mathbf{x}_1$, i.e. $NC(\mathbf{x}_i) = d(\mathbf{x}_i, \mathbf{x}_1)$. |
| *Trajectory sum of squares* | The sum of squares of the internal variation in the ecological states that conform trajectory $\mathbf{T}$. |
| *Trajectory internal variation* | An unbiased estimator of the internal variance in the ecological states that conform trajectory $\mathbf{T}$. |
| *Contribution of states to internal variation* | The *absolute* (sum of squares) or *relative* contributions of individual ecological states to the temporal variation in trajectory $\mathbf{T}$. |

:::

::: {.column width="30%"}
![](resources/img/changes_state.webp)
:::

::::



::: footer
4. Characterizing trajectories
:::

## Characterizing changes in state

:::: {.columns}

::: {.column width="70%"}

| Metric            |  Example question(s)                               |
|-------------------|----------------------------------------------------|
| Segment/trajectory length  | *Which entity has changed the most?* *What has been the impact of particular events (e.g. disturbances)?* |
| Segment/trajectory speed  | *Which entity has faster dynamics?* *What period corresponds to faster dynamics?* |
| Net change | *Is the target entity returning to its initial state after a disturbance?* |
| Trajectory internal variation | *Is the target entity temporally stable?* *What observation has the most unique state?* |
:::

::: {.column width="30%"}
![](resources/img/changes_state.webp)
:::

::::



::: footer
4. Characterizing trajectories
:::
## Characterizing changes in state

One can obtain the length of trajectory segments and the total path length:

```{r, echo =TRUE} 
trajectoryLengths(x)
```

. . .

In addition to segment lengths, one can also calculate the distance (i.e. the *Net change*) between all states and the initial, which is taken as reference:

```{r, echo =TRUE} 
trajectoryLengths(x, relativeToInitial = TRUE)
```

. . .

When observation times are available, it may be of interest to calculate segment or trajectory speeds using:

```{r, echo = TRUE} 
trajectorySpeeds(xt)
```

. . .

Finally, one may calculate the internal variation of states within each trajectory using:
```{r, echo = TRUE}
trajectoryInternalVariation(x)
```

::: footer
4. Characterizing trajectories
:::

## Characterizing changes in direction


:::: {.columns}

::: {.column width="70%"}

| Metric            |  Description                                       |
|-------------------|----------------------------------------------------|
| *Angle between consecutive segments*  | The angle (change in direction) between two consecutive segments on the corresponding plane formed by the corresponding triplet. |
| *Angle with respect to an initial state*  | The total path length of a trajectory $\mathbf{T}$ is the sum of the lengths of its directed segments. |
| *Angle with respect to 2D axes* | The angle between a particular segment and the first or second axis. | 
| *Trajectory directionality* | A weighed average of along the trajectory of the relative difference between angles and straight lines (180º). |
:::

::: {.column width="30%"}
![](resources/img/changes_direction.webp)
:::

::::

::: footer
4. Characterizing trajectories
:::


## Characterizing changes in direction


:::: {.columns}

::: {.column width="70%"}

| Metric            |  Example question(s)                                      |
|-------------------|----------------------------------------------------|
| Angle between consecutive segments  | *Are there abrupt changes in direction of dynamics?* |
| Angle with respect to an initial state  | *Does the trajectory continue the initial direction?* |
| Angle with respect to 2D axes | *Can the direction of changes be interpreted?* | 
| Trajectory directionality | *Do dynamics of the target entity follow the same direction consistently?* |
:::

::: {.column width="30%"}
![](resources/img/changes_direction.webp)
:::

::::

::: footer
4. Characterizing trajectories
:::

## Characterizing changes in direction

Function `trajectoryAngles()` allows calculating the angles between consecutive segments:

```{r, echo = TRUE} 
trajectoryAngles(x)
```

Mean and standard deviation statistics of angles are calculated according to circular statistics. 

. . . 

We can use the same function to calculate angles relative to the initial state:

```{r, echo = TRUE} 
trajectoryAngles(x, relativeToInitial = TRUE)
```

. . .

To measure the overall directionality of a trajectory (i.e. if the path consistently follows the same direction in $\Omega$ ), we recommend using function `trajectoryDirectionality()`:

```{r, echo = TRUE} 
trajectoryDirectionality(x)
```  


::: footer
4. Characterizing trajectories
:::


## Assessing multiple metrics at once

It is possible to assess multiple trajectory metrics in one function call to `trajectoryMetrics()`. This will only provide metrics that apply to the whole trajectory: 

```{r, echo = TRUE}
trajectoryMetrics(xt)
```

. . .

Another function, called `trajectoryWindowMetrics()` calculates trajectory metrics on moving windows over trajectories, but will not be illustrated here.


::: footer
4. Characterizing trajectories
:::

# 5. Comparing target states to reference trajectories {background-color="#008080"}

## Distances, relative positions and shifts


:::: {.columns}

::: {.column width="70%"}

| Metric            |  Example question(s)                                       |
|-------------------|----------------------------------------------------|
| Distance between $\mathbf{y}$ and $\mathbf{T}$  | *How likely is that the target entity will follow the dynamics of the reference trajectory?* |
| Relative position of  $proj(\mathbf{y}, \mathbf{T})$ with respect to $\mathbf{T}$  | *How far is the target from the final (mature) state of the reference dynamics?* |
| Time shift of observed state with respect to $\mathbf{T}$  | *Does the observation of the target state represents a phenological advance/delay?* |

:::

::: {.column width="30%"}
![](resources/img/comparing_target_reference.webp)
:::

::::

::: footer
5. Comparing states to trajectories
:::


## Relative positions and orthogonal projection

Ecological states occupy a **relative position** within their trajectory that depends on the total path length of the trajectory. 

. . .

Function `trajectoryProjection()` allows obtaining the relative position of each ecological state of a trajectory:

```{r, echo = TRUE} 
trajectoryProjection(x$d, 1:4, 1:4)
```  

. . .

The same function can also be used to perform an **orthogonal projection** of arbitrary ecological states onto a given **reference trajectory**. 

. . .

For example we can study the projection of third state of the trajectory of entity '2' (i.e. state 7) onto the trajectory of entity '1' (i.e. states 1 to 4), which happens to be in the half of the trajectory:

```{r, echo = TRUE} 
trajectoryProjection(x$d, 7, 1:4)
```  


::: footer
5. Comparing states to trajectories
:::

## Trajectory shifts

Sometimes different ecosystems follow the same or similar path but with different speeds, or with an observations starting at a different point in the dynamic sequence. 

. . .

We can quantify those differences using function `trajectoryShifts()`, which internally uses orthogonal projection. 

. . .

To illustrate this function, we will use a small data set of two **parallel** trajectories, but where the second is shifted:

```{r, echo = TRUE}
entities3 <- c("1","1","1","1","2","2","2","2")
times3 <- c(1,2,3,4,1,2,3,4)
xy3<-matrix(0, nrow=8, ncol=2)
xy3[2,2]<-1
xy3[3,2]<-2
xy3[4,2]<-3
xy3[5:8,1] <- 0.25
xy3[5:8,2] <- xy3[1:4,2] + 0.5 # States are all shifted with respect to entity "1"
x_shift <- defineTrajectories(dist(xy3), entities3, times = times3)
```


::: footer
5. Comparing states to trajectories
:::

## Trajectory shifts

We can see the differences graphically:

```{r, fig = TRUE, fig.height=3, fig.width=5, fig.align = "center"}
par(mar=c(4,4,1,1))
trajectoryPCoA(x_shift,  time.labels = TRUE,
               traj.colors = c("black","red"), lwd = 2)
legend("topright", col=c("black","red"), 
       legend=c("Entity 1", "Entity 2"), bty="n", lty=1, lwd = 2)
```


Function `trajectoryShifts()` allows comparing different observations to a reference trajectory:

```{r, echo = TRUE}
trajectoryShifts(x_shift)
```


We see that the observations of trajectory "2" correspond to states of trajectory "1" at 0.5 time units later in time. Surveys with missing values indicate that the projection of the target state cannot be determined (because the reference trajectory is too short).


::: footer
5. Comparing states to trajectories
:::

# 6. Comparing pairs of trajectories {background-color="#008080"}

## Trajectory convergence/divergence

:::: {.columns}

::: {.column width="65%"}

| Metric            |  Example question(s)                                       |
|-------------------|----------------------------------------------------|
| **Asymmetric** conv./div.  | *Are the states of of the target trajectory becoming closer/farther to the reference trajectory over time?* |
| **Symmetric** conv./div.   | *Are the states of the two trajectories becoming closer/farther over time?* |
| **Multiple** conv./div.  | *Are the states of the multiple entities becoming more similar over time?* |

:::

::: {.column width="35%"}
![](resources/img/convergence_divergence.webp)
:::

::::


::: footer
6. Comparing pairs of trajectories
:::

## Trajectory convergence/divergence

If the trajectories are synchronous (i.e., their observations where done at the same times), one can analyze the sequence of distances between consecutive observations:

```{r, echo = TRUE} 
trajectoryConvergence(x, type = "pairwise.symmetric")
```  

. . .

Note that this test can be straightforwardly generalized to multiple trajectories:

```{r, echo = TRUE} 
trajectoryConvergence(x, type = "multiple")
```  

. . .

Trajectory convergence/divergence can also be studied **asymmetrically** using:

```{r, echo = TRUE, eval = FALSE} 
trajectoryConvergence(xt, type = "pairwise.asymmetric")
```  


. . .

::: callout-note
Check out other ways of describing trajectory relationships in function `trajectoryRMA()`!.
:::


::: footer
6. Comparing pairs of trajectories
:::

## Trajectory dissimilarity

Calculating the dissimilarity between a pair of trajectories allows quantifying the resemblance in dynamics of the corresponding pair of ecological entities. 

. . .

There are multiple ways of assessing the dissimilarity in dynamics, e.g.:

| Coefficient               |  Differences included                      |
|---------------------------|--------------------------------------------|
| *Segment path distance (SPD)*  | Position, shape. |
| *Directed segment path distance (DSPD)*  | Position, shape, direction. |
| *Time-sensitive path distance (TSPD)*  | Position, shape, direction, speed. |

. . .

Function `trajectoryDistances()` allows calculating several of them, and returns a distance matrix containing the dissimilarity between pairs of trajectories:

```{r, echo = TRUE}
trajectoryDistances(xt, distance.type = "TSPD")
```


. . .

::: callout-note
A detailed comparison of trajectory dissimilarity indices can be found in article [Distance metrics for trajectory resemblance](https://emf-creaf.github.io/ecotraj/articles/TrajectoryDistanceMetrics.html).
:::

::: footer
6. Comparing pairs of trajectories
:::


# 7. Variation in ecological dynamics {background-color="#008080"}

## Space of trajectory dissimilarity

Calculating the dissimilarity between all pairs of entities results in a new space ($\Omega_\mathbf{T}$) of resemblance in ecological dynamics.

![](resources/img/space_dissimilarity.webp)

::: footer
7. Variation in ecological dynamics
:::


## Variation in dynamics


:::: {.columns}

::: {.column width="55%"}

| Metric            |  Usage(s)                                   |
|-------------------|----------------------------------------------------|
| Unconstrained ordination analysis on $\mathbf{D_T}$  | *Display resemblance in ecological dynamics* |
| Cluster analysis on $\mathbf{D_T}$  | *Identify and characterize groups of entities with similar dynamics* |
| Sum of squares of $\mathbf{D_T}$  | *Quantify the amount of variation in ecological dynamics* |
| Contribution of individual trajectories  | *Assess the degree of uniqueness in ecological dynamics* |
| Constrained ordination analysis on $\mathbf{D_T}$  | *Model variation in ecological dynamics* |

:::

::: {.column width="45%"}
![](resources/img/dynamic_variation.webp)
:::

::::


::: footer
7. Variation in ecological dynamics
:::


## Variation in dynamics

One may be interested in knowing how much diverse are a set of trajectories, and which entities follow dynamics more distinct from others. We refer to the diversity of trajectories as **dynamic variation**., and these questions can be addressed using:

```{r, echo = TRUE} 
dynamicVariation(xt)
```  

. . .

Analogously to `trajectoryInternalVariation()`, function `dynamicVariation()` returns the sum of squares of dynamic variation, an unbiased dynamic variance estimator and the relative contribution of individual trajectories to the overall sum of squares. 

. . .

Function `dynamicVariation()`, makes internal calls to `trajectoryDistances()`, which means that we may get slightly different results if we change the trajectory dissimilarity coefficient:

```{r, echo = TRUE} 
dynamicVariation(xt, distance.type = "TSPD")
```  

::: footer
7. Variation in ecological dynamics
:::

# 7. Transforming trajectories {background-color="#008080"}

## Trajectory interpolation

Sometimes the available trajectory data is non-synchronous, due to **missing observations** or observation times that **do not match** across trajectories.

. . .

Trajectory interpolation allows recalculating positions along trajectory pathways so that observation times are the same across all trajectories, hence obtaining a **synchronous** data set.

. . .

For example, here we interpolate trajectories in `xt` to times `c(1, 1.5, 2, 2.5)` (the observation times of entity '3') to obtain a synchronous data set:

```{r, echo = TRUE}
xt_inter <- interpolateTrajectories(xt, times = c(1, 1.5, 2.0, 2.5))
```


. . .

The following trajectory plots show the effect of interpolation visually:

```{r, fig = TRUE, fig.height=4, fig.width=8, fig.align = "center"}
oldpar <- par(mfrow=c(1,2), mar = c(4,4,1,1))
trajectoryPCoA(xt, 
               traj.colors = c("black","red", "blue"), time.labels = TRUE,
               lwd = 2)
title("Initial")
legend("topright", col=c("black","red", "blue"), 
       legend=c("Entity 1", "Entity 2", "Entity 3"), bty="n", lty=1, lwd = 2)
trajectoryPCoA(xt_inter, 
               traj.colors = c("black","red", "blue"), time.labels = TRUE,
               lwd = 2)
title("Interpolated")
```


::: footer
8. Transforming trajectories
:::

## Trajectory centering

Trajectory centering removes differences in (e.g. initial or overall) *position* between trajectories, without changing their shape, to focus on the direction of temporal changes.

. . .

Trajectory centering is done using function `centerTrajectories()`:

```{r, echo = TRUE}
x_cent <- centerTrajectories(x)
```

. . .

The following trajectory plots show the effect of centering visually:

```{r, fig = TRUE, fig.height=4, fig.width=8, fig.align = "center"}
oldpar <- par(mfrow=c(1,2), mar = c(4,4,1,1))
trajectoryPCoA(x, 
               traj.colors = c("black","red", "blue"),
               lwd = 2)
title("Before centering")
legend("topright", col=c("black","red", "blue"), 
       legend=c("Entity 1", "Entity 2", "Entity 3"), bty="n", lty=1, lwd = 2)
trajectoryPCoA(x_cent, 
               traj.colors = c("black","red", "blue"), 
               lwd = 2)
title("After centering")
```


::: footer
8. Transforming trajectories
:::

## Trajectory smoothing

Trajectories may contain variation that is considered *noise*, for whatever reason (e.g. measurement error). Similarly to univariate smoothing of temporal series, noise can be smoothed out in trajectory data.

. . .

Temporal smoothing of trajectories done using function `smoothTrajectories()`, which applies a multivariate moving average over each trajectory and uses a **Gaussian kernel** to specify average weights. 

. . .

The following plots illustrate the effect of smoothing:

```{r}
data("avoca")
avoca_D_man <- vegclust::vegdiststruct(avoca_strat, method="manhattan", transform = function(x){log(x+1)})
years <- c(1971, 1974, 1978, 1983, 1987, 1993, 1999, 2004, 2009)
avoca_times <- years[avoca_surveys]
avoca_x <- defineTrajectories(avoca_D_man,  
                              sites = avoca_sites, 
                              times = avoca_times)
avoca_x_smooth <- smoothTrajectories(avoca_x)
```


```{r trajectory_smooth_plot, echo=FALSE, warning = FALSE, fig.height=4, fig.width=8, fig.align = "center"}
oldpar <- par(mar=c(4,4,1,1), mfrow=c(1,2))
trajectoryPCoA(avoca_x,
               traj.colors = RColorBrewer::brewer.pal(8,"Accent"), 
               axes=c(1,2), length=0.1, lwd=2)
title("Before smoothing")
trajectoryPCoA(avoca_x_smooth,
               traj.colors = RColorBrewer::brewer.pal(8,"Accent"), 
               axes=c(1,2), length=0.1, lwd=2)
title("After smoothing")
par(oldpar)
```

::: footer
8. Transforming trajectories
:::

#  {background-color="#008080"}

![M.C. Escher - Waterfall, 1961](resources/img/Escher_waterfall.png)
